```
有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。

求所能获得硬币的最大数量。
 

示例 1：
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167

示例 2：

输入：nums = [1,5]
输出：10
```

首先想到回溯算法，但复杂度太高，通不过（力扣上有笔记记录了这一方法）

因为想象解题空间`n*n`大小，第 `i` 行有`n - i`种选择，复杂度`n!`大小，复杂度排行`O(n)<O(nlogn)<O(n^2)<O(n^3)...<O(n!)<O(2^n)`

**动态规划**: `dp[i][j]=x`表示戳破`i`和`j`之间（开区间，不包括`i`和`j`）所有气球，可以获得的最高分数`x`

- 设`i`和`j`之间最后戳破的气球编号为`k`，`(i,j)`区间内`k`两边已经被戳破，左右两边互不干扰，绕开子问题不独立的困境

```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        //将nums数组移植到新数组中
        int[] coins = new int[n + 2];
        // coins[0]和coins[n+1]可以看作是两个虚拟气球
        coins[0] = coins[n + 1] = 1;
        for (int i = 1; i < n + 1; i++) {
            coins[i] = nums[i - 1];
        }
        // dp[i][j]:(i, j)之间得到的最多分数，注意开区间，因为最后要求的是 dp[0][n+1]，不包括边界
        // 通过base case和最终状态dp[0][n+1]确定遍历方向
        int[][] dp = new int[n + 2][n + 2];
        for (int i = n; i >= 0; i--) {
            for (int j = i + 1; j < n + 2; j++) {
                for (int k = i + 1; k < j; k++) {
                    // 将编号为 k 的气球最后戳破，因为 k 是最后戳破，所以(i, k)和(k, j)之间的已经戳破了
                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + coins[i] * coins[k] * coins[j]);
                }
            }
        }
        return dp[0][n + 1];
    }
}
```
