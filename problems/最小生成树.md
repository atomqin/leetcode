**最小生成树**:最小连通子图(不唯一)，所有边权重之和最小
## Prim
O(n^2)
/*
S:当前已经在联通块中的所有点的集合
1. dist[i] = INF
2. for n 次
    t<-S外离S最近的点
    利用t更新S外点到S的距离
    st[t] = true
n次迭代之后所有点都已加入到S中
联系：Dijkstra算法是更新不在集合中的点到起始点的距离，Prim是更新不在集合中的点到集合S的距离
*/
注意，一个点t到集合s的距离，指的是：若点t和集合s中的3个点有边相连。则点t到集合s的距离就是，t与3个点相连的边中，权重最小的那条边的权重。
- 写法一
```java
class Solution {
    int N = 110;
    //更新节点时防止溢出，惯用写法
    int INF = 0x3f3f3f3f;
    //w[a][b] = c:a到b的有权重为c的边
    int[][] w = new int[N][N];
    //dist[x] = y: 起点到x的最短距离为y
    int[] dist = new int[N];
    int n, k;
    boolean[] visited = new boolean[N];
    public int networkDelayTime(int[][] times, int n, int k) {
        this.n = n;
        this.k = k;        
        for(int i = 1; i < n + 1; i++){
            for(int j = 1; j < n + 1; j++){
                w[i][j] = i == j ? 0 : INF;
            }
        }
        for (int[] time : times) {
            int u = time[0], v = time[1], c = time[2];
            w[u][v] = c;
        }
        int ans = Prim();
        return ans;
    }
    private int Prim(){
        Arrays.fill(dist, INF);
        //初始化，
        dist[k] = 0;
        //最小生成树的所有边权重之和
        int res = 0;
        //循环n次，遍历n个顶点
        for(int i = 0; i < n; i++){
            int t = -1;
            //O(n^2)
            for(int j = 1; j <= n; j++){
                //找未访问过的点中距离已访问点集合最近的点
                //第一轮循环后t=k
                if(!visited[j] && (t == -1 || dist[t] > dist[j])) t = j;
            }
            //不是第一个取出的节点，并且当前节点的距离为INF,则表示没有和集合中点相连的边。
            if(i != 0 && dist[t] == INF) return INF;
            //i = 0 时， dist[k] = 0
            if(i != 0) res += dist[t];
            visited[t] = true;
            //注意和Dijkstra算法的区别
            //O(m)
            //更新到集合S的最短距离
            for(int j = 1; j <= n; j++){
                dist[j] = Math.min(dist[j], w[t][j]);
            }
        }
    }  
}
```
- 写法二
parents[toIndex] = fromIndex: 路径走向 fromIndex->toIndex
```java
public class Prim {
    public static void main(String[] args) {
        int[][] matrix = { { 0, 4, 3, INF, INF }, { 4, 0, 8, 7, INF }, { 3, 8, 0, INF, 1 }, { INF, 7, INF, 0, 9 },
                { INF, INF, 1, 9, 0 } };
        int[] path = prim(matrix);
        System.out.println(Arrays.toString(path));
    }

    private final static int INF = 0x3f3f3f3f;

    private static int[] prim(int[][] matrix) {
        //最小生成树数组，根结点没有父结点，首元素设为-1
        int[] parents = new int[matrix.length];
        int fromIndex = 0, toIndex = 0;
        Set<Integer> visited = new HashSet<>();
        parents[0] = -1;
        visited.add(0);
        while (visited.size() < matrix.length) {
            int weight = INF;
            //从已触达顶点出发，寻找到达新顶点的权值最小的边
            for (int vertex : visited) {
                for (int j = 0; j < matrix.length; j++) {
                    if (!visited.contains(j) && matrix[vertex][j] < weight) {
                        fromIndex = vertex;
                        toIndex = j;
                        weight = matrix[fromIndex][toIndex];
                    }
                }
            }
            visited.add(toIndex);
            parents[toIndex] = fromIndex;
        }
        return parents;
    }
}
```
- 堆优化版Prim写法参考堆优化Dijkstra写法
## Kruksal
时间复杂度O(mlogm)
**算法步骤**:
- 将所有边按权重从小到大排序
- 枚举每条边 a - b，权重为c
  - if a, b 不连通，将（a - b）这条边加入集合中 
[1631 最小体力消耗路径](https://leetcode-cn.com/problems/path-with-minimum-effort/)
