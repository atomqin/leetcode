## Prim
O(n^2)
```java
class Solution {
    int N = 110;
    //更新节点时防止溢出，惯用写法
    int INF = 0x3f3f3f3f;
    //w[a][b] = c:a到b的有权重为c的边
    int[][] w = new int[N][N];
    //dist[x] = y: 起点到x的最短距离为y
    int[] dist = new int[N];
    int n, k;
    boolean[] visited = new boolean[N];
    public int networkDelayTime(int[][] times, int n, int k) {
        this.n = n;
        this.k = k;        
        for(int i = 1; i < n + 1; i++){
            for(int j = 1; j < n + 1; j++){
                w[i][j] = i == j ? 0 : INF;
            }
        }
        for (int[] time : times) {
            int u = time[0], v = time[1], c = time[2];
            w[u][v] = c;
        }
        int ans = Prim();
        return ans;
    }
    private int Prim(){
        Arrays.fill(dist, INF);
        //初始化，起点到起点最短距离为0
        dist[k] = 0;
        //最小生成树的所有边权重之和
        int res = 0;
        //循环n次，遍历n个顶点
        for(int i = 0; i < n; i++){
            int t = -1;
            //O(n^2)
            for(int j = 1; j <= n; j++){
                //找未访问过的点中距离起点最近的点
                //第一轮循环后t=k
                if(!visited[j] && (t == -1 || dist[t] > dist[j])) t = j;
            }
            //不连通
            if(i != 0 && dist[t] == INF) return INF;
            //i = 0 时， dist[k] = 0
            if(i != 0) res += dist[t];
            visited[t] = true;
            //用找到的t更新其他点到整个集合的最短距离
            //注意和Dijkstra算法的区别
            //O(m)
            for(int j = 1; j <= n; j++){
                dist[j] = Math.min(dist[j], w[t][j]);
            }
        }
    }  
}
```
## Kruksal
时间复杂度O(mlogm)
**算法步骤**:
- 将所有边按权重从小到大排序
- 枚举每条边 a - b，权重为c
  - if a, b 不连通，将（a-b）加入集合中 
