![图1](http://assets.processon.com/chart_image/610bd980637689310e690d6d.png)

### 朴素Dijkstra
```java

class Solution {
    int N = 110;
    int INF = 0x3f3f3f3f;
    //w[a][b] = c:a到b的有权重为c的边
    int[][] w = new int[N][N];
    //dist[x] = y: 起点到x的最短距离为y
    int[] dist = new int[N];
    int n, k;
    boolean[] visited = new boolean[N];
    public int networkDelayTime(int[][] times, int n, int k) {
        this.n = n;
        this.k = k;        
        for(int i = 1; i < n + 1; i++){
            for(int j = 1; j < n + 1; j++){
                w[i][j] = i == j ? 0 : INF;
            }
        }
        for (int[] time : times) {
            int u = time[0], v = time[1], c = time[2];
            w[u][v] = c;
        }
        Dijkstra();
        int ans = 0;
        for(int i = 1; i <= n; i++){
            ans = Math.max(ans, dist[i]);
        }
        return ans > INF/2 ? -1 : ans;
        
    }
    private void Dijkstra(){
        Arrays.fill(dist, INF);
        dist[k] = 0;
        //循环n次
        for(int p = 0; p < n; p++){
            int t = -1;
            for(int i = 1; i <= n; i++){
                //找未访问过的点中距离起点最近的点
                //第一轮循环后t=k
                if(!visited[i] && (t == -1 || dist[t] > dist[i])) t = i;
            }
            visited[t] = true;
            //用找到的t更新其他点
            for(int j = 1; j <= n; j++){
                dist[j] = Math.min(dist[j], dist[t] + w[t][j]);
            }
        }
    }  
}
```
