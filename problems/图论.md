[宫水三叶讲解](https://mp.weixin.qq.com/s/2Ba8-NI7lQh2_MvMpg-CZg)

[例题743](https://leetcode-cn.com/problems/network-delay-time/submissions/)

n为点数，m为边数
# 多源汇最短路
### Floyd算法
时间复杂度O(n^3)

跑一遍 Floyd，可以得到「从任意起点出发，到达任意起点的最短距离」。

然后从所有 w[k][x] 中取最大值，即是「从起点 k 出发，到其他点的最短距离的最大值」
```java
class Solution {
    //根据题目条件，不怕溢出
    int N = 110, M = 6010;
    int INF = 0x3f3f3f3f;
    //w[i][j]: 顶点i到j的边的权值之和
    int[][] w = new int[N][N];
    int n, k;
    boolean[] visited = new boolean[N];
   
    public int networkDelayTime(int[][] times, int n, int k) {
        this.n = n;
        this.k = k;
       
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= n; j++){
                w[i][j] = i == j ? 0 : INF;
            }
        }
        for (int[] time : times) {
            int u = time[0], v = time[1], c = time[2];
            w[u][v] = c;
        }
        floyd();
        int ans = 0;
        for(int i = 1; i <= n; i++){
            ans = Math.max(ans, w[k][i]);
        }
        return ans == INF ? -1 : ans;
        
    }
    private void floyd(){
        Arrays.fill(dist, INF);
        
        //遍历顺序：中转点->起点->终点
        for(int k = 1; k <= n; k++){
            for(int i = 1; i <= n; i++){
                for(int j = 1; j <= n; j++){
                    w[i][j] = Math.min(w[i][k] + w[k][j], w[i][j]);
                }
            }
        }
    }  
}
```
# 单源最短路
## 所有边权都是正数
### 朴素Dijkstra
时间复杂度O(n^2)，适用于**稠密图**（m ~ n^2）
```java
class Solution {
    int N = 110;
    //更新节点时防止溢出，惯用写法
    int INF = 0x3f3f3f3f;
    //w[a][b] = c:a到b的有权重为c的边
    int[][] w = new int[N][N];
    //dist[x] = y: 起点到x的最短距离为y
    int[] dist = new int[N];
    int n, k;
    boolean[] visited = new boolean[N];
    public int networkDelayTime(int[][] times, int n, int k) {
        this.n = n;
        this.k = k;        
        for(int i = 1; i < n + 1; i++){
            for(int j = 1; j < n + 1; j++){
                w[i][j] = i == j ? 0 : INF;
            }
        }
        for (int[] time : times) {
            int u = time[0], v = time[1], c = time[2];
            w[u][v] = c;
        }
        Dijkstra();
        int ans = 0;
        for(int i = 1; i <= n; i++){
            ans = Math.max(ans, dist[i]);
        }
        
        return ans == INF ? -1 : ans;
        
    }
    private void Dijkstra(){
        Arrays.fill(dist, INF);
        //初始化，起点到起点最短距离为0
        dist[k] = 0;
        //循环n次，遍历n个顶点
        for(int p = 0; p < n; p++){
            int t = -1;
            //O(n^2)
            for(int i = 1; i <= n; i++){
                //找未访问过的点中距离起点最近的点
                //第一轮循环后t=k
                if(!visited[i] && (t == -1 || dist[t] > dist[i])) t = i;
            }
            visited[t] = true;
            //用找到的t更新其他点
            //O(m)
            for(int j = 1; j <= n; j++){
                dist[j] = Math.min(dist[j], dist[t] + w[t][j]);
            }
        }
    }  
}
```
### 堆优化Dijkstra算法
堆插入元素复杂度O(logn)，遍历邻接表里的边复杂度O(m)，故时间复杂度 O(mlogn) 适用于**稀疏图**（边数量接近点数量，m ~ n）
```java
import java.util.PriorityQueue;

class Solution {
    //根据题目条件，不怕溢出
    int N = 110, M = 6010;
    int INF = 0x3f3f3f3f;
    //e[idx]:编号为idx的边指向的顶点
    //h[i]:顶点i能够连通的边的集合（相当于是链表）的头结点
    //ne[idx]:编号为idx的边的下一条边
    //w[idx]:编号为idx的边的权重
    int[] e = new int[M], h = new int[N], ne = new int[M], w = new int[M];
    //dist[x] = y: 起点到x的最短距离为y
    int[] dist = new int[N];
    int n, k, idx;
    boolean[] visited = new boolean[N];
    //顶点a指向的边的集合:邻接表添加顶点a指向顶点b的边
    private void add(int a, int b, int c){
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx;
        w[idx] = c;
        idx++;
    }

    public int networkDelayTime(int[][] times, int n, int k) {
        this.n = n;
        this.k = k;
        //初始化头结点为-1        
        Arrays.fill(h, -1);
        for (int[] time : times) {
            int u = time[0], v = time[1], c = time[2];
            add(u, v, c);
        }
        Dijkstra();
        int ans = 0;
        for(int i = 1; i <= n; i++){
            ans = Math.max(ans, dist[i]);
        }
        return ans == INF ? -1 : ans;
        
    }
    private void Dijkstra(){
        Arrays.fill(dist, INF);
        dist[k] = 0;
        //存储[顶点编号j, dist[j]]
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1] - b[1]);
        pq.add(new int[]{k, 0});
        //O(mlogn)
        while(!pq.isEmpty()){
            int[] poll = pq.poll(); 
            int id = poll[0], dis = poll[1];
            visited[id] = true;
            //顶点id指向的边的集合
            for(int i = h[id]; i != -1; i = ne[i]){
                //编号为i的边指向的订点
                int j = e[i];
                if(dist[j] > dis + w[i]){
                    dist[j] = dis + w[i];
                    pq.add(new int[]{j, dist[j]});
                }
            }
        }
    }  
}
```
## 存在负权边
### Bellman Ford
时间复制度 O(nm) 适用场景：有边数限制的最短路，**可能存在负权边**

### SPFA(邻接表)
